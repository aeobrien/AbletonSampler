import SwiftUI
import AVFoundation

struct LoopEditorView: View {
    @Binding var samplePart: MultiSamplePartData
    let audioFileURL: URL
    let totalFrames: Int64
    @Environment(\.dismiss) var dismiss
    
    // State for loop markers
    @State private var sustainLoopStartPosition: Double = 0.0 // Normalized 0-1
    @State private var sustainLoopEndPosition: Double = 1.0
    @State private var releaseLoopStartPosition: Double = 0.0
    @State private var releaseLoopEndPosition: Double = 1.0
    
    // State for UI
    @State private var activeLoopType: LoopType = .sustain
    @State private var isEditingSustainLoop: Bool = false
    @State private var isEditingReleaseLoop: Bool = false
    @State private var waveformWidth: CGFloat = 0
    @State private var waveformRMSData: [Float] = []
    @State private var isLoadingWaveform = true
    @State private var maxRMSValue: Float = 0.001
    @State private var amplitudeScale: CGFloat = 1.0
    
    // Dragging state
    @State private var draggedMarker: DraggedLoopMarker? = nil
    @GestureState private var dragOffset: CGSize = .zero
    
    enum LoopType {
        case sustain
        case release
    }
    
    enum DraggedLoopMarker {
        case sustainStart
        case sustainEnd
        case releaseStart
        case releaseEnd
    }
    
    var body: some View {
        VStack(spacing: 15) {
            Text("Loop Editor")
                .font(.title2)
                .foregroundColor(.primary) // Ensure text is visible
            
            Text("Editing: \(audioFileURL.lastPathComponent)")
                .font(.caption)
                .lineLimit(1)
                .foregroundColor(.secondary)
            
            // Loop Type Selector
            Picker("Loop Type", selection: $activeLoopType) {
                Text("Sustain Loop").tag(LoopType.sustain)
                Text("Release Loop").tag(LoopType.release)
            }
            .pickerStyle(.segmented)
            .padding(.horizontal)
            
            // Waveform Display with Loop Markers
            Rectangle()
                .fill(Color.gray.opacity(0.2))
                .frame(height: 150)
                .overlay(
                    Text("Waveform visualization coming soon")
                        .foregroundColor(.secondary)
                )
            
            // Loop Controls
            VStack(spacing: 10) {
                if activeLoopType == .sustain {
                    // Sustain Loop Controls
                    Toggle("Enable Sustain Loop", isOn: $isEditingSustainLoop)
                        .onChange(of: isEditingSustainLoop) { _, newValue in
                            if newValue {
                                samplePart.sustainLoopMode = 1 // Forward by default
                            } else {
                                samplePart.sustainLoopMode = 0 // Off
                            }
                        }
                    
                    if isEditingSustainLoop {
                        HStack {
                            Text("Mode:")
                            Picker("Mode", selection: $samplePart.sustainLoopMode) {
                                Text("Forward").tag(1)
                                Text("Ping-Pong").tag(2)
                            }
                            .pickerStyle(.segmented)
                        }
                        
                        HStack {
                            Text("Crossfade:")
                            Slider(value: $samplePart.sustainLoopCrossfade, in: 0...1)
                            Text(String(format: "%.2f", samplePart.sustainLoopCrossfade))
                        }
                        
                        Toggle("Link Sample Start to Loop Start", isOn: $samplePart.link)
                    }
                } else {
                    // Release Loop Controls
                    Toggle("Enable Release Loop", isOn: $isEditingReleaseLoop)
                        .onChange(of: isEditingReleaseLoop) { _, newValue in
                            if newValue {
                                samplePart.releaseLoopMode = 1 // Forward by default
                            } else {
                                samplePart.releaseLoopMode = 3 // Off
                            }
                        }
                    
                    if isEditingReleaseLoop {
                        HStack {
                            Text("Mode:")
                            Picker("Mode", selection: $samplePart.releaseLoopMode) {
                                Text("Forward").tag(1)
                                Text("Ping-Pong").tag(2)
                            }
                            .pickerStyle(.segmented)
                        }
                        
                        HStack {
                            Text("Crossfade:")
                            Slider(value: $samplePart.releaseLoopCrossfade, in: 0...1)
                            Text(String(format: "%.2f", samplePart.releaseLoopCrossfade))
                        }
                    }
                }
            }
            .padding(.horizontal)
            
            // Action Buttons
            HStack {
                Button("Cancel", role: .cancel) {
                    dismiss()
                }
                Spacer()
                Button("Apply") {
                    applyLoopSettings()
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding(.horizontal)
            
            Spacer()
        }
        .padding()
        .frame(width: 700, height: 600) // Use fixed size instead of min
        .background(Color(NSColor.windowBackgroundColor)) // Add background
        .onAppear {
            print("LoopEditorView appeared for file: \(audioFileURL.lastPathComponent), frames: \(totalFrames)")
        }
        .task {
            // await loadWaveform()
            initializeLoopPositions()
        }
    }
    
    // Initialize loop positions from existing data
    private func initializeLoopPositions() {
        if let sustainStart = samplePart.sustainLoopStart,
           let sustainEnd = samplePart.sustainLoopEnd {
            sustainLoopStartPosition = Double(sustainStart) / Double(totalFrames)
            sustainLoopEndPosition = Double(sustainEnd) / Double(totalFrames)
            isEditingSustainLoop = samplePart.sustainLoopMode > 0
        }
        
        if let releaseStart = samplePart.releaseLoopStart,
           let releaseEnd = samplePart.releaseLoopEnd {
            releaseLoopStartPosition = Double(releaseStart) / Double(totalFrames)
            releaseLoopEndPosition = Double(releaseEnd) / Double(totalFrames)
            isEditingReleaseLoop = samplePart.releaseLoopMode != 3
        }
    }
    
    // Apply loop settings to the sample part
    private func applyLoopSettings() {
        if isEditingSustainLoop {
            samplePart.sustainLoopStart = Int64(sustainLoopStartPosition * Double(totalFrames))
            samplePart.sustainLoopEnd = Int64(sustainLoopEndPosition * Double(totalFrames))
        } else {
            samplePart.sustainLoopStart = nil
            samplePart.sustainLoopEnd = nil
            samplePart.sustainLoopMode = 0
        }
        
        if isEditingReleaseLoop {
            samplePart.releaseLoopStart = Int64(releaseLoopStartPosition * Double(totalFrames))
            samplePart.releaseLoopEnd = Int64(releaseLoopEndPosition * Double(totalFrames))
        } else {
            samplePart.releaseLoopStart = nil
            samplePart.releaseLoopEnd = nil
            samplePart.releaseLoopMode = 3
        }
    }
    
    // Create drag gesture for loop markers
    private func createDragGesture(for marker: DraggedLoopMarker) -> some Gesture {
        DragGesture(minimumDistance: 1)
            .updating($dragOffset) { value, state, _ in
                state = value.translation
                DispatchQueue.main.async {
                    if self.draggedMarker == nil {
                        self.draggedMarker = marker
                    }
                }
            }
            .onEnded { value in
                finalizeMarkerDrag(marker: marker, dragTranslation: value.translation)
                self.draggedMarker = nil
            }
    }
    
    // Finalize marker position after drag
    private func finalizeMarkerDrag(marker: DraggedLoopMarker, dragTranslation: CGSize) {
        guard waveformWidth > 0 else { return }
        
        let normalizedDelta = dragTranslation.width / waveformWidth
        
        switch marker {
        case .sustainStart:
            sustainLoopStartPosition = max(0, min(sustainLoopEndPosition - 0.01, sustainLoopStartPosition + normalizedDelta))
        case .sustainEnd:
            sustainLoopEndPosition = max(sustainLoopStartPosition + 0.01, min(1, sustainLoopEndPosition + normalizedDelta))
        case .releaseStart:
            releaseLoopStartPosition = max(0, min(releaseLoopEndPosition - 0.01, releaseLoopStartPosition + normalizedDelta))
        case .releaseEnd:
            releaseLoopEndPosition = max(releaseLoopStartPosition + 0.01, min(1, releaseLoopEndPosition + normalizedDelta))
        }
    }
    
    // Load waveform data (simplified version from AudioSegmentEditorView)
    @MainActor
    private func loadWaveform() async {
        isLoadingWaveform = true
        waveformRMSData = []
        
        do {
            let file = try AVAudioFile(forReading: audioFileURL)
            let format = file.processingFormat
            let frameCount = Int(file.length)
            
            guard let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: AVAudioFrameCount(frameCount)) else {
                throw NSError(domain: "AudioLoadError", code: 1)
            }
            
            try file.read(into: buffer)
            
            guard let floatChannelData = buffer.floatChannelData else {
                throw NSError(domain: "AudioLoadError", code: 2)
            }
            
            let channelPtr = floatChannelData[0]
            let audioDataCopy = [Float](UnsafeBufferPointer(start: channelPtr, count: frameCount))
            
            // Calculate RMS display samples
            let samplesPerPixel = 1024
            let displaySamplesCount = max(1, frameCount / samplesPerPixel)
            var rmsSamples = [Float](repeating: 0.0, count: displaySamplesCount)
            
            // RMS calculation
            for i in 0..<displaySamplesCount {
                let startFrame = i * samplesPerPixel
                let endFrame = min(startFrame + samplesPerPixel, frameCount)
                let frameCountInBlock = endFrame - startFrame
                
                if frameCountInBlock > 0 {
                    var sumOfSquares: Float = 0.0
                    for j in startFrame..<endFrame {
                        let sample = audioDataCopy[j]
                        sumOfSquares += sample * sample
                    }
                    rmsSamples[i] = sqrt(sumOfSquares / Float(frameCountInBlock))
                }
            }
            
            self.waveformRMSData = rmsSamples
            self.maxRMSValue = rmsSamples.max() ?? 0.001
            self.amplitudeScale = min(0.75 / CGFloat(self.maxRMSValue), 50.0)
            self.isLoadingWaveform = false
            
        } catch {
            print("Error loading waveform: \(error)")
            self.isLoadingWaveform = false
        }
    }
    
    // Draw waveform
    private func drawWaveform(context: inout GraphicsContext, size: CGSize) {
        guard !waveformRMSData.isEmpty, size.width > 0, size.height > 0 else { return }
        
        let halfHeight = size.height / 2
        let dataCount = waveformRMSData.count
        
        let path = Path { p in
            for i in 0..<dataCount {
                let xPosition = (CGFloat(i) / CGFloat(dataCount - 1)) * size.width
                let rmsValue = CGFloat(waveformRMSData[i])
                let scaledAmplitude = rmsValue * amplitudeScale
                
                let yTop = max(0, halfHeight - (scaledAmplitude * halfHeight))
                let yBottom = min(size.height, halfHeight + (scaledAmplitude * halfHeight))
                
                if i == 0 {
                    p.move(to: CGPoint(x: xPosition, y: yTop))
                } else {
                    p.addLine(to: CGPoint(x: xPosition, y: yTop))
                }
                p.addLine(to: CGPoint(x: xPosition, y: yBottom))
                p.addLine(to: CGPoint(x: xPosition, y: yTop))
            }
        }
        
        context.stroke(path, with: .color(.accentColor), lineWidth: 1)
    }
}

// Loop Region Overlay View
struct LoopRegionOverlay: View {
    let startPosition: Double
    let endPosition: Double
    let color: Color
    let width: CGFloat
    let height: CGFloat
    
    var body: some View {
        Rectangle()
            .fill(color)
            .frame(width: max(1, (endPosition - startPosition) * width), height: height)
            .offset(x: startPosition * width, y: 0)
    }
}

// Loop Marker View
struct LoopMarkerView: View {
    let position: Double
    let color: Color
    let label: String
    let isBeingDragged: Bool
    let viewHeight: CGFloat
    let viewWidth: CGFloat
    
    var body: some View {
        VStack(spacing: 0) {
            // Label
            Text(label)
                .font(.caption)
                .foregroundColor(.white)
                .padding(.horizontal, 4)
                .padding(.vertical, 2)
                .background(color)
                .cornerRadius(4)
            
            // Marker line
            Rectangle()
                .fill(color)
                .frame(width: 2, height: viewHeight - 20)
                .opacity(isBeingDragged ? 1.0 : 0.8)
        }
        .position(x: position * viewWidth, y: viewHeight / 2)
        .contentShape(Rectangle().size(width: 20, height: viewHeight))
    }
}